<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Apocalypse - Point & Click Survival</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            overflow: hidden;
            cursor: crosshair;
        }

        #gameContainer {
            display: flex;
            height: 100vh;
        }

        #mapContainer {
            flex: 1;
            position: relative;
        }

        #map {
            height: 100vh;
            filter: grayscale(80%) sepia(20%) hue-rotate(60deg) brightness(0.8);
            cursor: crosshair;
        }

        .moving-cursor {
            cursor: wait !important;
        }

        .leaflet-container {
            cursor: crosshair !important;
        }

        .leaflet-clickable {
            cursor: pointer !important;
        }

        .leaflet-routing-container {
            display: none !important;
        }

        #sidebar {
            width: 320px;
            background: #0d1117;
            border-left: 2px solid #00ff00;
            padding: 20px;
            overflow-y: auto;
        }

        .stats-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .stat-bar {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            align-items: center;
        }

        .bar {
            width: 150px;
            height: 12px;
            background: #30363d;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #21262d;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.5s ease;
        }

        .health { background: linear-gradient(90deg, #ff4444, #ff6666); }
        .stamina { background: linear-gradient(90deg, #44ff44, #66ff66); }
        .hunger { background: linear-gradient(90deg, #ffaa44, #ffcc66); }

        .inventory {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .inventory h3 {
            color: #00ff00;
            margin-bottom: 10px;
            text-align: center;
        }

        .item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #30363d;
            cursor: pointer;
            transition: background 0.2s;
        }

        .item:hover {
            background: #21262d;
        }

        .action-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .action-button {
            background: #238636;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            width: 100%;
            margin: 5px 0;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s;
            position: relative;
        }

        .action-button:hover:not(:disabled) {
            background: #2ea043;
            transform: translateY(-1px);
        }

        .action-button:disabled {
            background: #656d76;
            cursor: not-allowed;
            transform: none;
        }

        .building-panel {
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            display: none;
        }

        .building-panel.active {
            display: block;
        }

        .building-info {
            background: #1f2328;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
        }

        .location-info {
            background: #1f2328;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            margin: 10px 0;
            font-size: 13px;
        }

        .danger-level {
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .danger-low { background: #238636; color: white; }
        .danger-medium { background: #fb8500; color: white; }
        .danger-high { background: #da3633; color: white; }

        .game-log {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            height: 180px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            margin: 3px 0;
            padding: 3px;
            border-left: 3px solid transparent;
            padding-left: 8px;
        }

        .log-success { 
            color: #3fb950; 
            border-left-color: #3fb950;
            background: rgba(63, 185, 80, 0.1);
        }
        .log-warning { 
            color: #d29922; 
            border-left-color: #d29922;
            background: rgba(210, 153, 34, 0.1);
        }
        .log-danger { 
            color: #f85149; 
            border-left-color: #f85149;
            background: rgba(248, 81, 73, 0.1);
        }
        .log-info {
            color: #58a6ff;
            border-left-color: #58a6ff;
            background: rgba(88, 166, 255, 0.1);
        }

        .movement-indicator {
            position: absolute;
            width: 30px;
            height: 30px;
            background: rgba(255, 255, 0, 0.6);
            border: 2px solid #ffff00;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            animation: pulse-move 1s ease-out;
        }

        @keyframes pulse-move {
            0% { 
                transform: scale(0.5);
                opacity: 1;
            }
            100% { 
                transform: scale(1.5);
                opacity: 0;
            }
        }

        .zombie-marker {
            width: 20px;
            height: 20px;
            background: #ff0000;
            border: 2px solid #000;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            animation: zombie-pulse 2s infinite;
            cursor: pointer;
        }

        @keyframes zombie-pulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 5px #ff0000;
            }
            50% { 
                transform: scale(1.1);
                box-shadow: 0 0 15px #ff0000;
            }
        }

        .controls-info {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(13, 17, 23, 0.95);
            padding: 12px;
            border-radius: 6px;
            border: 1px solid #30363d;
            font-size: 12px;
            max-width: 300px;
        }

        .distance-indicator {
            font-size: 11px;
            color: #7d8590;
            font-style: italic;
        }

        .cooldown-timer {
            position: absolute;
            top: 2px;
            right: 2px;
            background: #da3633;
            color: white;
            border-radius: 3px;
            padding: 1px 4px;
            font-size: 10px;
        }

        .building-highlight {
            background: rgba(0, 255, 0, 0.3) !important;
            border: 2px solid #00ff00 !important;
        }

        .map-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #238636;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            z-index: 1000;
        }

        .map-toggle:hover {
            background: #2ea043;
        }

        .game-over {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .game-over-content {
            background: #161b22;
            border: 2px solid #da3633;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            color: #ff0000;
        }

        .restart-btn {
            background: #238636;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="mapContainer">
            <div id="map"></div>
            <div class="controls-info">
                <div><strong>üßü ZOMBIE APOCALYPSE</strong></div>
                <div>üìç Click anywhere to move</div>
                <div>üè¢ Click buildings to interact</div>
                <div>üßü Avoid red zombie markers</div>
                <div>‚ö° Watch your stamina!</div>
            </div>
            <button class="map-toggle" onclick="toggleMapView()">üó∫Ô∏è Toggle Map</button>
        </div>
        
        <div id="sidebar">
            <div class="stats-panel">
                <h3>üéÆ SURVIVOR STATUS</h3>
                <div class="stat-bar">
                    <span>‚ù§Ô∏è Health:</span>
                    <div class="bar">
                        <div class="bar-fill health" id="healthBar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span>‚ö° Stamina:</span>
                    <div class="bar">
                        <div class="bar-fill stamina" id="staminaBar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-bar">
                    <span>üçñ Hunger:</span>
                    <div class="bar">
                        <div class="bar-fill hunger" id="hungerBar" style="width: 100%"></div>
                    </div>
                </div>
            </div>

            <div class="location-info">
                <div><strong>üìç Current Location:</strong></div>
                <div id="currentLocation">New York City</div>
                <div style="margin-top: 8px;">
                    <strong>‚ö†Ô∏è Threat Level:</strong>
                    <span id="dangerLevel" class="danger-level danger-low">LOW</span>
                </div>
                <div class="distance-indicator" id="distanceInfo">Click to move around</div>
            </div>

            <div class="action-panel">
                <h3>üéØ QUICK ACTIONS</h3>
                <button class="action-button" onclick="useItem('üçñ Food')" id="eatBtn">
                    üçñ Eat Food
                </button>
                <button class="action-button" onclick="useItem('üíß Water')" id="drinkBtn">
                    üíß Drink Water
                </button>
                <button class="action-button" onclick="useItem('ü©π Bandages')" id="healBtn">
                    ü©π Use Bandage
                </button>
                <button class="action-button" onclick="rest()" id="restBtn">
                    üò¥ Rest (Recover Stamina)
                </button>
            </div>

            <div class="inventory">
                <h3>üéí INVENTORY</h3>
                <div id="inventoryList">
                    <div class="item">
                        <span>üéí Backpack</span>
                        <span>1</span>
                    </div>
                    <div class="item">
                        <span>üî™ Knife</span>
                        <span>1</span>
                    </div>
                </div>
            </div>

            <div class="building-panel" id="buildingPanel">
                <h3>üè¢ BUILDING INTERACTION</h3>
                <div class="building-info">
                    <div><strong id="buildingName">Unknown Building</strong></div>
                    <div id="buildingDetails" style="margin-top: 5px;"></div>
                </div>
                <button class="action-button" id="searchBtn" onclick="searchBuilding()">
                    üîç Search Building
                </button>
                <button class="action-button" onclick="closeBuildingPanel()" style="background: #656d76;">
                    üö™ Leave Building
                </button>
            </div>

            <div class="game-log">
                <div><strong>üìú SURVIVAL LOG</strong></div>
                <div id="logEntries">
                    <div class="log-entry log-info">Game started. Click to move and survive!</div>
                    <div class="log-entry log-warning">The apocalypse has begun...</div>
                </div>
            </div>
        </div>
    </div>

    <div class="game-over" id="gameOverScreen">
        <div class="game-over-content">
            <h2>üíÄ GAME OVER üíÄ</h2>
            <p id="gameOverMessage">You didn't survive the apocalypse...</p>
            <button class="restart-btn" onclick="restartGame()">üîÑ Try Again</button>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script>
        // Game state
        let gameState = {
            player: {
                lat: 40.7128,
                lng: -74.0060,
                health: 100,
                stamina: 100,
                hunger: 100,
                isMoving: false,
                moveSpeed: 15 // meters per second
            },
            inventory: {
                'üéí Backpack': 1,
                'üî™ Knife': 1,
                'ü©π Bandages': 3,
                'üíß Water': 5,
                'üçñ Food': 8
            },
            lootedBuildings: new Set(),
            zombies: [],
            gameTime: 0,
            actionCooldowns: {},
            currentBuilding: null,
            survivalTime: 0
        };

        // Initialize map
        const map = L.map('map', {
            zoomControl: true,
            attributionControl: false
        }).setView([gameState.player.lat, gameState.player.lng], 17);

        // Tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
        }).addTo(map);

        // Player marker
        const playerIcon = L.divIcon({
            className: 'player-icon',
            html: '<div style="width: 25px; height: 25px; background: #00ff00; border: 3px solid #fff; border-radius: 50%; box-shadow: 0 0 15px #00ff00; display: flex; align-items: center; justify-content: center; font-size: 14px;">üë§</div>',
            iconSize: [25, 25],
            iconAnchor: [12, 12]
        });

        let playerMarker = L.marker([gameState.player.lat, gameState.player.lng], {
            icon: playerIcon,
            zIndexOffset: 1000
        }).addTo(map);

        // After playerMarker is defined
        let routingControl = L.Routing.control({
            // Waypoints will be set dynamically
            waypoints: [], 
            // We will use the OSRM demo server for now.
            // Note: This demo server can be unreliable. If issues arise,
            // we may need to configure a different routing service.
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1' 
            }),
            // Do not add the control to the map visually, as we'll use it programmatically.
            addWaypoints: false, // Prevent adding waypoints via UI
            draggableWaypoints: false, // Prevent dragging waypoints
            routeWhileDragging: false, // Disable dragging-based routing
            show: false, // Attempt to hide the control UI (itinerary, etc.)
            fitSelectedRoutes: false, // Do not zoom to the route automatically
            lineOptions: { // Style the route line
                styles: [
                    {color: 'yellow', opacity: 0.7, weight: 6, dashArray: '10, 10'}
                ]
            }
        }).addTo(map);
            // as the line should be drawn by the routing machine plugin itself.

        // To effectively hide the control's UI if it were added to the map:
        // If it needs to be added for event handling, apply CSS to hide it:
        // Create a dummy div to attach the control to, then hide that div.
        // However, the library might allow creating it without adding to map.
        // For now, let's assume not adding it to map is enough.
        // We will trigger routing programmatically.

        routingControl.on('routesfound', function(e) {
            const routes = e.routes;
            if (routes.length === 0) {
                addLogEntry('No route could be found.', 'warning');
                gameState.player.isMoving = false;
                document.body.classList.remove('moving-cursor');
                return;
            }

            const route = routes[0];
            addLogEntry(`Route found: ${Math.round(route.summary.totalDistance)}m. Moving...`, 'info');
            
            // Update distance info display if available
            const distanceInfoEl = document.getElementById('distanceInfo');
            if (distanceInfoEl) {
                distanceInfoEl.textContent = `Path: ${Math.round(route.summary.totalDistance)}m`;
            }
            
            animateMovement(route.coordinates, route.summary.totalDistance);
        });

        routingControl.on('routingerror', function(e) {
            addLogEntry(`Routing error: ${e.error.message || 'Could not find a route.'}`, 'danger');
            gameState.player.isMoving = false;
            document.body.classList.remove('moving-cursor');
            // Potentially clear the waypoints if a partial route was drawn or something
            // routingControl.setWaypoints([]); 
        });


        let animationFrameId = null; // To control the animation loop

        function animateMovement(pathCoordinates, totalPathDistance) {
            let currentPathIndex = 0;
            let distanceCoveredInCurrentSegment = 0;
            let totalDistanceCovered = 0;
            let lastTimestamp = performance.now();

            // Initial stamina cost (the one checked in movePlayerTo) can be deducted here,
            // or we can make stamina purely based on distance moved during animation.
            // For now, let's assume the initial check in movePlayerTo was a gate,
            // and actual cost is per meter moved.
            // const initialStaminaForAttempt = Math.min(Math.floor(totalPathDistance / 20), 25); // This was removed from movePlayerTo
            // if (gameState.player.stamina < initialStaminaForAttempt) { // This check is now removed
            //      addLogEntry('Not enough stamina to start movement!', 'warning');
            //      gameState.player.isMoving = false;
            //      document.body.classList.remove('moving-cursor');
            //      return;
            // }
            // Decided to make stamina cost purely based on actual movement in the loop below.

            function animationStep(timestamp) {
                const deltaTime = (timestamp - lastTimestamp) / 1000; // seconds
                lastTimestamp = timestamp;

                if (currentPathIndex >= pathCoordinates.length - 1) {
                    // Reached destination
                    playerMarker.setLatLng(pathCoordinates[pathCoordinates.length - 1]);
                    gameState.player.lat = pathCoordinates[pathCoordinates.length - 1].lat;
                    gameState.player.lng = pathCoordinates[pathCoordinates.length - 1].lng;
                    
                    addLogEntry(`Arrived at destination. Total distance: ${Math.round(totalPathDistance)}m.`, 'success');
                    completeMovement();
                    return;
                }

                const playerCurrentLatLng = playerMarker.getLatLng();
                const nextWaypointLatLng = pathCoordinates[currentPathIndex + 1];
                
                let distanceToNextWaypoint = playerCurrentLatLng.distanceTo(nextWaypointLatLng);
                let segmentMoveDistance = gameState.player.moveSpeed * deltaTime;

                // Stamina cost for this frame's movement: e.g. 1 stamina per 10 meters
                const staminaCostThisFrame = (segmentMoveDistance / 10) * 1; 
                if (gameState.player.stamina < staminaCostThisFrame) {
                    addLogEntry('Ran out of stamina mid-journey!', 'warning');
                    completeMovement(); // Stop movement
                    return;
                }
                gameState.player.stamina = Math.max(0, gameState.player.stamina - staminaCostThisFrame);
                // updateUI(); // updateUI is called in completeMovement and periodically by gameLoop

                if (segmentMoveDistance >= distanceToNextWaypoint) {
                    // Jump to the next waypoint and prepare for the next segment
                    playerMarker.setLatLng(nextWaypointLatLng);
                    totalDistanceCovered += distanceToNextWaypoint;
                    currentPathIndex++;
                    distanceCoveredInCurrentSegment = 0; // Reset for new segment
                    if (currentPathIndex >= pathCoordinates.length - 1) { // Check again if it was the last segment
                         gameState.player.lat = nextWaypointLatLng.lat;
                         gameState.player.lng = nextWaypointLatLng.lng;
                         addLogEntry(`Arrived at destination. Total distance: ${Math.round(totalPathDistance)}m.`, 'success');
                         completeMovement();
                         return;
                    }
                } else {
                    // Move along the current segment
                    const bearing = L.GeometryUtil.bearing(playerCurrentLatLng, nextWaypointLatLng);
                    const newLatLng = L.GeometryUtil.destination(playerCurrentLatLng, bearing, segmentMoveDistance);
                    playerMarker.setLatLng(newLatLng);
                    totalDistanceCovered += segmentMoveDistance;
                    distanceCoveredInCurrentSegment += segmentMoveDistance;
                }
                
                gameState.player.lat = playerMarker.getLatLng().lat;
                gameState.player.lng = playerMarker.getLatLng().lng;

                // Update distance info if available
                const distanceInfoEl = document.getElementById('distanceInfo');
                if (distanceInfoEl) {
                    const remainingDistance = totalPathDistance - totalDistanceCovered;
                    distanceInfoEl.textContent = `Moving... ${Math.round(remainingDistance)}m remaining.`;
                }
                
                updateUI(); // Continuous UI update during movement for stamina bar etc.
                animationFrameId = requestAnimationFrame(animationStep);
            }

            // Cancel any previous animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            animationFrameId = requestAnimationFrame(animationStep);
        }

        function completeMovement() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            gameState.player.isMoving = false;
            document.body.classList.remove('moving-cursor');
            updateUI(); // Final UI update

            const distanceInfoEl = document.getElementById('distanceInfo');
            if (distanceInfoEl) {
                distanceInfoEl.textContent = 'Click to move around'; // Reset
            }

            if (Math.random() < 0.1) { 
                encounterZombie();
            }
        }

        // Building types and loot tables
        const buildingTypes = {
            'hospital': {
                name: 'üè• Hospital',
                loot: { 'üíä Medical Kit': [2, 4], 'ü©π Bandages': [3, 6], 'üíâ Morphine': [1, 2] },
                danger: 'high',
                description: 'Medical supplies but crawling with infected'
            },
            'supermarket': {
                name: 'üõí Supermarket',
                loot: { 'üçñ Food': [4, 10], 'üíß Water': [3, 8], 'üîã Batteries': [2, 4] },
                danger: 'medium',
                description: 'Good supplies, moderate zombie presence'
            },
            'pharmacy': {
                name: 'üíä Pharmacy',
                loot: { 'üíä Medicine': [2, 5], 'ü©π Bandages': [2, 4], 'üß¥ Vitamins': [1, 3] },
                danger: 'medium',
                description: 'Medical supplies with some risk'
            },
            'restaurant': {
                name: 'üçΩÔ∏è Restaurant',
                loot: { 'üçñ Food': [3, 7], 'üíß Water': [2, 4], 'üî™ Kitchen Knife': [0, 1] },
                danger: 'low',
                description: 'Food supplies, relatively safe'
            },
            'school': {
                name: 'üè´ School',
                loot: { 'üìö Books': [1, 3], 'üîß Tools': [1, 2], 'üçé Food': [2, 4] },
                danger: 'low',
                description: 'Basic supplies, low threat'
            },
            'bank': {
                name: 'üè¶ Bank',
                loot: { 'üí∞ Cash': [100, 500], 'üóùÔ∏è Safe Keys': [0, 1], 'üí≥ Cards': [1, 3] },
                danger: 'high',
                description: 'Valuable items but heavily defended'
            },
            'house': {
                name: 'üè† House',
                loot: { 'üçñ Food': [2, 5], 'üíß Water': [1, 3], 'üëï Clothes': [1, 2], 'üîß Tools': [0, 2] },
                danger: 'low',
                description: 'Family home with basic supplies'
            },
            'apartment': {
                name: 'üè¢ Apartment',
                loot: { 'üçñ Food': [3, 7], 'üíß Water': [2, 5], 'üëï Clothes': [2, 4], 'üì± Electronics': [1, 2] },
                danger: 'medium',
                description: 'Multiple units to search'
            },
            'default': {
                name: 'üè¢ Building',
                loot: { 'üóëÔ∏è Scrap': [1, 4], 'üîß Basic Tools': [0, 2] },
                danger: 'low',
                description: 'Unknown building type'
            }
        };

        // Spawn zombies around the map
        function spawnZombies() {
            const center = map.getCenter();
            const bounds = map.getBounds();
            
            for (let i = 0; i < 20; i++) {
                const lat = bounds.getSouth() + Math.random() * (bounds.getNorth() - bounds.getSouth());
                const lng = bounds.getWest() + Math.random() * (bounds.getEast() - bounds.getWest());
                
                const zombieIcon = L.divIcon({
                    className: 'zombie-icon',
                    html: '<div class="zombie-marker">üßü</div>',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });

                const zombie = L.marker([lat, lng], { 
                    icon: zombieIcon,
                    zIndexOffset: 500
                }).addTo(map);
                
                // Add click handler for zombies
                zombie.on('click', function(e) {
                    e.originalEvent.stopPropagation();
                    encounterZombie();
                });
                
                gameState.zombies.push(zombie);
            }
        }

        // Handle map clicks for movement and building interaction
        map.on('click', async function(e) {
            const { lat, lng } = e.latlng;
            
            // Check if clicking near a zombie
            for (let zombie of gameState.zombies) {
                const zombiePos = zombie.getLatLng();
                const distance = map.distance([lat, lng], [zombiePos.lat, zombiePos.lng]);
                if (distance < 50) {
                    encounterZombie();
                    return;
                }
            }

            // Show movement indicator
            showMovementIndicator(e.containerPoint);
            
            // Try to query for buildings first
            const query = `
                [out:json][timeout:15];
                (
                  way["building"](around:30,${lat},${lng});
                  relation["building"](around:30,${lat},${lng});
                );
                out geom;
            `;

            let foundBuilding = false;
            
            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });
                const data = await response.json();

                if (data.elements && data.elements.length > 0) {
                    const building = data.elements[0];
                    foundBuilding = true;
                    
                    // Move to building first
                    await movePlayerTo(lat, lng);
                    
                    // Then interact with building
                    interactWithBuilding(building, lat, lng);
                    return;
                }
            } catch (error) {
                console.error('Building query failed:', error);
            }

            // If no building found, just move
            if (!foundBuilding) {
                movePlayerTo(lat, lng);
            }
        });

        function showMovementIndicator(point) {
            const indicator = document.createElement('div');
            indicator.className = 'movement-indicator';
            indicator.style.left = (point.x - 15) + 'px';
            indicator.style.top = (point.y - 15) + 'px';
            document.getElementById('mapContainer').appendChild(indicator);
            
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.parentNode.removeChild(indicator);
                }
            }, 1000);
        }

        async function movePlayerTo(lat, lng) {
            if (gameState.player.isMoving) return false; // Return false if already moving

            // const distanceToTarget = map.distance([gameState.player.lat, gameState.player.lng], [lat, lng]);
            // const staminaCost = Math.min(Math.floor(distanceToTarget / 20), 25); // Removed this line

            // A minimal stamina check to even attempt, e.g., must have at least 1 stamina
            if (gameState.player.stamina <= 0) { 
                addLogEntry('Not enough stamina to even attempt moving!', 'warning');
                return false;
            }

            gameState.player.isMoving = true;
            document.body.classList.add('moving-cursor');
            addLogEntry('Calculating route...', 'info');

            // Clear previous routes if any (important if the route line was ever displayed)
            // routingControl.setWaypoints([]); // This might clear the line from the map if it was drawn

            routingControl.setWaypoints([
                L.latLng(gameState.player.lat, gameState.player.lng),
                L.latLng(lat, lng)
            ]);

            // The actual movement/animation will be triggered by an event listener 
            // on routingControl (e.g., 'routesfound') which will be set up in the next step.
            // For now, this function initiates the routing.

            // The old logic for consuming stamina, updating player state,
            // and random zombie encounter will be moved to the path following logic.
            
            return true; // Indicate that movement process has started
        }

        function interactWithBuilding(building, lat, lng) {
            const buildingId = building.id || `${lat}_${lng}`;
            
            // Determine building type
            let buildingType = 'default';
            const tags = building.tags || {};
            
            if (tags.amenity === 'hospital') buildingType = 'hospital';
            else if (tags.amenity === 'pharmacy') buildingType = 'pharmacy';
            else if (tags.amenity === 'restaurant') buildingType = 'restaurant';
            else if (tags.amenity === 'school') buildingType = 'school';
            else if (tags.amenity === 'bank') buildingType = 'bank';
            else if (tags.shop === 'supermarket') buildingType = 'supermarket';
            else if (tags.building === 'house') buildingType = 'house';
            else if (tags.building === 'apartments') buildingType = 'apartment';
            
            const buildingInfo = buildingTypes[buildingType];
            gameState.currentBuilding = { id: buildingId, type: buildingType, info: buildingInfo };
            
            // Update UI
            document.getElementById('buildingName').textContent = buildingInfo.name;
            document.getElementById('buildingDetails').textContent = buildingInfo.description;
            document.getElementById('buildingPanel').classList.add('active');
            
            // Update danger level
            updateDangerLevel(buildingInfo.danger);
            
            addLogEntry(`Entered ${buildingInfo.name}`, 'info');
        }

        function searchBuilding() {
            if (!gameState.currentBuilding) return;
            
            const buildingId = gameState.currentBuilding.id;
            const buildingInfo = gameState.currentBuilding.info;
            
            if (gameState.lootedBuildings.has(buildingId)) {
                addLogEntry('This building has already been searched.', 'warning');
                return;
            }
            
            // Check if action is on cooldown
            if (gameState.actionCooldowns.search && Date.now() < gameState.actionCooldowns.search) {
                const remainingTime = Math.ceil((gameState.actionCooldowns.search - Date.now()) / 1000);
                addLogEntry(`Must wait ${remainingTime}s before searching again.`, 'warning');
                return;
            }
            
            // Set cooldown
            gameState.actionCooldowns.search = Date.now() + 5000;
            
            // Danger check based on building type
            let encounterChance = 0.1;
            if (buildingInfo.danger === 'medium') encounterChance = 0.3;
            if (buildingInfo.danger === 'high') encounterChance = 0.5;
            
            if (Math.random() < encounterChance) {
                encounterZombie();
                return;
            }
            
            // Generate loot
            const loot = {};
            for (const [item, range] of Object.entries(buildingInfo.loot)) {
                const amount = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
                if (amount > 0) {
                    loot[item] = amount;
                }
            }
            
            // Add loot to inventory
            let foundItems = [];
            for (const [item, amount] of Object.entries(loot)) {
                if (gameState.inventory[item]) {
                    gameState.inventory[item] += amount;
                } else {
                    gameState.inventory[item] = amount;
                }
                foundItems.push(`${item} x${amount}`);
            }
            
            gameState.lootedBuildings.add(buildingId);
            
            if (foundItems.length > 0) {
                addLogEntry(`Found: ${foundItems.join(', ')}`, 'success');
            } else {
                addLogEntry('The building was empty...', 'warning');
            }
            
            updateUI();
        }

        function closeBuildingPanel() {
            document.getElementById('buildingPanel').classList.remove('active');
            gameState.currentBuilding = null;
            updateDangerLevel('low');
            addLogEntry('Left the building', 'info');
        }

        function encounterZombie() {
            const weapons = ['üî™ Knife', 'üó°Ô∏è Sword', 'üî® Hammer', '‚öîÔ∏è Weapon'];
            let hasWeapon = false;
            
            for (const weapon of weapons) {
                if (gameState.inventory[weapon] && gameState.inventory[weapon] > 0) {
                    hasWeapon = true;
                    break;
                }
            }
            
            const damage = hasWeapon ? Math.floor(Math.random() * 20) + 10 : Math.floor(Math.random() * 40) + 20;
            gameState.player.health = Math.max(0, gameState.player.health - damage);
            
            const message = hasWeapon ? 
                `Fought off a zombie with your weapon! Lost ${damage} health.` :
                `Zombie attack! No weapon to defend. Lost ${damage} health.`;
            
            addLogEntry(message, 'danger');
            updateUI();
            
            if (gameState.player.health <= 0) {
                gameOver('Killed by zombies');
            }
        }

        function useItem(item) {
            if (!gameState.inventory[item] || gameState.inventory[item] <= 0) {
                addLogEntry(`No ${item} available!`, 'warning');
                return;
            }
            
            gameState.inventory[item]--;
            
            switch(item) {
                case 'üçñ Food':
                    gameState.player.hunger = Math.min(100, gameState.player.hunger + 30);
                    addLogEntry('Ate food. Hunger reduced.', 'success');
                    break;
                case 'üíß Water':
                    gameState.player.hunger = Math.min(100, gameState.player.hunger + 20);
                    addLogEntry('Drank water. Thirst quenched.', 'success');
                    break;
                case 'ü©π Bandages':
                    gameState.player.health = Math.min(100, gameState.player.health + 25);
                    addLogEntry('Used bandage. Health restored.', 'success');
                    break;
            }
            
            updateUI();
        }

        function rest() {
            if (gameState.actionCooldowns.rest && Date.now() < gameState.actionCooldowns.rest) {
                const remainingTime = Math.ceil((gameState.actionCooldowns.rest - Date.now()) / 1000);
                addLogEntry(`Must wait ${remainingTime}s before resting again.`, 'warning');
                return;
            }
            
            gameState.actionCooldowns.rest = Date.now() + 10000;
            gameState.player.stamina = Math.min(100, gameState.player.stamina + 40);
            addLogEntry('Rested and recovered stamina.', 'success');
            updateUI();
            
            // Small chance of zombie encounter while resting
            if (Math.random() < 0.2) {
                setTimeout(() => encounterZombie(), 2000);
            }
        }

        function updateUI() {
            // Update health bar
            document.getElementById('healthBar').style.width = gameState.player.health + '%';
            
            // Update stamina bar
            document.getElementById('staminaBar').style.width = gameState.player.stamina + '%';
            
            // Update hunger bar
            document.getElementById('hungerBar').style.width = gameState.player.hunger + '%';
            
            // Update inventory
            const inventoryList = document.getElementById('inventoryList');
            inventoryList.innerHTML = '';
            
            for (const [item, count] of Object.entries(gameState.inventory)) {
                if (count > 0) {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item';
                    itemDiv.innerHTML = `<span>${item}</span><span>${count}</span>`;
                    inventoryList.appendChild(itemDiv);
                }
            }
            
            // Update action buttons
            document.getElementById('eatBtn').disabled = !gameState.inventory['üçñ Food'] || gameState.inventory['üçñ Food'] <= 0;
            document.getElementById('drinkBtn').disabled = !gameState.inventory['üíß Water'] || gameState.inventory['üíß Water'] <= 0;
            document.getElementById('healBtn').disabled = !gameState.inventory['ü©π Bandages'] || gameState.inventory['ü©π Bandages'] <= 0;
            
            // Update rest button cooldown
            if (gameState.actionCooldowns.rest && Date.now() < gameState.actionCooldowns.rest) {
                const remainingTime = Math.ceil((gameState.actionCooldowns.rest - Date.now()) / 1000);
                document.getElementById('restBtn').innerHTML = `üò¥ Rest (${remainingTime}s)`;
                document.getElementById('restBtn').disabled = true;
            } else {
                document.getElementById('restBtn').innerHTML = 'üò¥ Rest (Recover Stamina)';
                document.getElementById('restBtn').disabled = false;
            }
            
            // Update search button cooldown
            if (gameState.actionCooldowns.search && Date.now() < gameState.actionCooldowns.search) {
                const remainingTime = Math.ceil((gameState.actionCooldowns.search - Date.now()) / 1000);
                document.getElementById('searchBtn').innerHTML = `üîç Search (${remainingTime}s)`;
                document.getElementById('searchBtn').disabled = true;
            } else {
                document.getElementById('searchBtn').innerHTML = 'üîç Search Building';
                document.getElementById('searchBtn').disabled = false;
            }
        }

        function updateDangerLevel(level) {
            const dangerElement = document.getElementById('dangerLevel');
            dangerElement.className = `danger-level danger-${level}`;
            dangerElement.textContent = level.toUpperCase();
        }

        function addLogEntry(message, type = 'info') {
            const logEntries = document.getElementById('logEntries');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            
            logEntries.appendChild(entry);
            logEntries.scrollTop = logEntries.scrollHeight;
            
            // Keep only last 50 entries
            while (logEntries.children.length > 50) {
                logEntries.removeChild(logEntries.firstChild);
            }
        }

        function gameOver(reason) {
            document.getElementById('gameOverMessage').textContent = reason;
            document.getElementById('gameOverScreen').style.display = 'flex';
            addLogEntry(`Game Over: ${reason}`, 'danger');
        }

        function restartGame() {
            // Reset game state
            gameState = {
                player: {
                    lat: 40.7128,
                    lng: -74.0060,
                    health: 100,
                    stamina: 100,
                    hunger: 100,
                    isMoving: false
                },
                inventory: {
                    'üéí Backpack': 1,
                    'üî™ Knife': 1,
                    'ü©π Bandages': 3,
                    'üíß Water': 5,
                    'üçñ Food': 8
                },
                lootedBuildings: new Set(),
                zombies: [],
                gameTime: 0,
                actionCooldowns: {},
                currentBuilding: null,
                survivalTime: 0
            };
            
            // Clear zombies
            gameState.zombies.forEach(zombie => map.removeLayer(zombie));
            gameState.zombies = [];
            
            // Reset player position
            playerMarker.setLatLng([gameState.player.lat, gameState.player.lng]);
            map.setView([gameState.player.lat, gameState.player.lng], 17);
            
            // Hide game over screen
            document.getElementById('gameOverScreen').style.display = 'none';
            
            // Close building panel
            closeBuildingPanel();
            
            // Respawn zombies
            spawnZombies();
            
            // Update UI
            updateUI();
            
            addLogEntry('Game restarted. Good luck survivor!', 'info');
        }

        function toggleMapView() {
            const currentZoom = map.getZoom();
            if (currentZoom > 15) {
                map.setZoom(13);
            } else {
                map.setZoom(17);
            }
        }

        // Game loop for hunger/stamina degradation
        function gameLoop() {
            gameState.gameTime++;
            gameState.survivalTime++;
            
            // Gradual hunger increase
            if (gameState.gameTime % 30 === 0) {
                gameState.player.hunger = Math.max(0, gameState.player.hunger - 1);
                if (gameState.player.hunger <= 0) {
                    gameState.player.health = Math.max(0, gameState.player.health - 5);
                    if (gameState.player.health <= 0) {
                        gameOver('Died of starvation');
                        return;
                    }
                }
            }
            
            // Gradual stamina recovery when not moving
            if (!gameState.player.isMoving && gameState.gameTime % 10 === 0) {
                gameState.player.stamina = Math.min(100, gameState.player.stamina + 1);
            }
            
            updateUI();
        }

        // Initialize game
        function initGame() {
            spawnZombies();
            updateUI();
            addLogEntry('Welcome to the zombie apocalypse!', 'info');
            addLogEntry('Click on the map to move around and find buildings to search.', 'info');
            
            // Start game loop
            setInterval(gameLoop, 1000);
            
            // Update cooldown timers
            setInterval(updateUI, 1000);
        }

        // Start the game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
